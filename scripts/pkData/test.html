<!DOCTYPE html>
<script src="tinytest.js"></script>
<script src="handler.js"></script>
<script src="exmpl.js"></script>
<script>
  const d = pkData
  function eqs (a, b) { return eq(JSON.stringify(a), JSON.stringify(b)) }
  function expectError(type, fn, ...args) {
    if (typeof fn != "function") {
      throw new TypeError(`This is not a function - ${typeof fn} ${JSON.stringify(fn)}; remember to not just call it`)
    }
    try {
      fn(...args)
      fail("Should have thrown " + type)
    } catch (error) {
      if (error.name = type) {
        return true
      } else {
        fail("Should have thrown " + type)
      }
    }
    return false
  }

  tests({
    // #todo fill in the exmpl sys data and use that for testing

    /* TinyTest Function Reference
    see https://github.com/joewalnes/jstinytest

    // Force a failure
    fail(reason)

    // Assert expression is truthy (fail with reason)
    assert(expression, reason)

    // Assert expected == actual
    eq(expected, actual)

    // Assert expected === actual
    assertStrictEquals(expected, actual)
    */

    'logging': function () {
      eq(d.prettyPrint(["A", "B", "C"]), `["A","B","C"]`)
      assert(expectError("TypeError",d.logWith, "foo"), `Not a function, should error`)
      d.logWith(console.log.bind(d, "TESTING..."))
      d.log("THIS SHOULD HAVE NO HEADER AND START WITH 'TESTING...'")
      d.hello()
    },

    'copy': function () {
      eqs(d.copy({ foo: 2, beep: 'A', bop: 1000, bip: undefined }), { foo: 2, beep: 'A', bop: 1000 })
      assert(expectError("TypeError", d.copy, undefined), `Shouldn't take 'undefined' as input`)
    },
    
    'system import': function () {
      assert(expectError("TypeError", d.checkId, {}), `No id, should error`)
      assert(expectError("TypeError", d.checkId, { id: "" }), `No valid id, should error`)
      let testId = "foo"
      let testSystem = { id: testId } // any empty lists will be disregarded
      assert(d.checkId(testSystem), `Has id, should return true`)
      eq(typeof d.describe(testSystem), "string")
      eq(d.listSystemIds().length, 0) // no systems imported yet
      assert(expectError("TypeError", d.importSystem, {}), `No id, should error`)
      assert(d.listSystemIds().length == 0, `System without ID shouldn't have been imported`)
      d.overrideSystem(testSystem)
      testSystem["bar"] = [{ id: 1 }, { id: 2 }, { id: 3 }]
      d.importSystem(testSystem)
      eq(d.listAll(testId, "bar").length, 3)
      testSystem["bar"] = [{ id: 3 }, { id: 4 }]
      d.importSystem(testSystem)
      eq(d.listAll(testId, "bar").length, 4)
      eq(d.listAll(testId, "biz"), undefined)
      assert(expectError("ReferenceError", d.exportSystem, "baz"), `Shouldn't find a system since this is not a stored id`)
      assert(d.isStored(testSystem), `Should have been imported`)
      eq(d.listSystemIds().length, 1)
      d.clearAll()
      assert(d.listSystemIds().length == 0, `System should have been deleted`)
      assert(expectError("ReferenceError", d.exportSystem, testId), `Shouldn't find a system, data should be cleared`)
    },

    'system read': function () {
      let id = exampleSys["id"]
      d.importSystem(exampleSys)
      eq(d.listAll(id, "members").length, exampleSys["members"].length)
      eq(d.listAll(id, "members")[0]["id"], exampleSys["members"][0]["id"])

    },
    // previous format: testName, setupResult, actualResult, expectedResult
    /* to convert
      // #todo figure out why this fails
      //unitTests.add('exportSystemData() overrideSystemData()', ["none", test_sysMangement(), true])

      unitTests.add('setGlobal() getGlobal()',
        //[setGlobal('foo', [1, 2]), getGlobal('foo'), [1, 2]]
      )
      // #todo delete foo later

    function runMemberTypeTest (k) {
        let pk = getById('member', k) // note: this will only work after the lib is initiated
        return [getNickname, isUtility, isAlt, isPrimary].map(f => f(pk))
      }
      let memberTypeFunctionTestNames = 'getNickname() isUtility() isAlt() isPrimary()'
      let memberTypeTests = {
        "knaqg": ["Echo",        true, false, false],
        "hdfqk": ["Damson",      false, false, true],
        "eedvu": ["Floop (Tea)", false, true, false]
      }
      Object.keys(memberTypeTests).forEach(pkId => {
        unitTests.add([memberTypeFunctionTestNames, runMemberTypeTest(pkId).join(' '), memberTypeTests[pkId]].join(' '))
      });

      function test_sysMangement () {
        let backup = exportSystemData()
        let initial = Object.keys(SYSTEM_STORAGE).length
        overrideSystemData({ 'foo': 'bar' }, false)
        let temp = Object.keys(SYSTEM_STORAGE).length
        overrideSystemData(backup, false)
        return (initial != temp) && (Object.keys(SYSTEM_STORAGE).length == initial)
      }
      
      function test_getFronters () {
        log(getFronters(2))
      }

      
      // #todo #later make this into a unit test and change it back after
      function test_updateEntryByType () {
        let testMember = {
          "privacy": {
            "visibility": "public",
            "name_privacy": "private",
            "description_privacy": "public",
            "pronoun_privacy": "public",
            "birthday_privacy": "public",
            "avatar_privacy": "public",
            "proxy_privacy": "public",
            "metadata_privacy": "public"
          },
          "uuid": "b62f0ab2-dc4f-4536-bb7f-7797690d3253"
        }
        let id = "kzkww" // Bee
        let testMember = getById("member", id)
        let field = "pronouns"
        //testMember["id"] = null

        log("Initial value set?", testMember[field] != "foo")
        testMember[field] = "foo"
        let changedMember = updateEntryByType('member', testMember)
        log("Updated in return value?", changedMember[field] == "foo")
        let doubleCheck = getById("member", id)
        log("Updated in system global?", doubleCheck[field] == "foo")
      }

      function test_objFromDescription () {
        pkData.clear();
        let description = getByName("member", "Hall")[0]["description"];
        log(objFromDescription(description));
      }

      function test_descriptionParsing () {
        let initial = log(twineObj().description, "(original)");
        let recompiled = discordStringFromObj(log(objFromDescription(initial)));
        if (recompiled !== initial) { log("Something is wrong with this recompiled description:", "\n" + recompiled) }
      }

      function test_getMemberGroups () {
        pkData.clear(); // so the Butler will use live data
        log(listNames(getMemberGroups()).join(", "))
      }

    */

  });
</script>